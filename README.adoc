
= ChaCha20 ISE for 64-bit RISC-V

*A lightweight Instruction Set Extension to accelerate the ChaCha20
 stream cipher on 64-bit RISC-V architectures.*

:toc:

== Remit & Background.

This ISE anticipates the question "what about ChaCha?" in the context
of the RISC-V Cryptography Extensions.
ChaCha is a popular algorithm in absoloute terms, but is not explicitly
supported by the current draft proposals.
This repository contains an example ISE showing how ChaCha *could* be
accelerated with dedicated instructions.

ChaCha <<rfc7539>> is a stream cipher, standardised by RFC.
There are several use cases listed in <<chachawiki>>, including
as an optional component of TLS1.3: "[an application] SHOULD implement [..]
TLS_CHACHA20_POLY1305_SHA256" <<tls1.3>>.
It is also used by various OS kernels as part of their DRBG implementations.
It is used exclusively by the WireGuard VPN <<wireguard>>.

This repository focuses *only* on the ChaCha20 block function.

== Basic ChaCha

A vanilla ChaCha implementation is found in `chacha_ref.c`.
It operates exclusivley on 32-bit elements.

An approximate instruction count is listed in the file, but can be broken
down as:

- `16` instructions to load the input state.

- A Quarter Round (QR) can be implemented on RISC-V using `12` instructions
  if the Bitmanip `rori` instruction is present.
  A round is hence `48` instructions.

- There are `20` rounds, hence the complete round function is `20*48=960`
  instructions in total.

- The final operation is to add the initial input to the block function
  output. This takes `16` instructions to load the initial inputs,
  `16` add instructions, and `16` store instructions, making `48` in total.

- An entire block operation hence takes roughly `1024` instructions.
  We ignore loop and stack maintainance instructions to simplify the
  analysis slightly.

The basic version of ChaCha can be run using `make run-reference`.

== The ISE: theory of operation

The ISE works only on RV64, and packs two elements into a single register.
The core accelerated function is the Quarter Round function, shown in
the diagram below:

.https://commons.wikimedia.org/w/index.php?curid=90771650[Diagram By Tony Arcieri - Own work, CC BY-SA 4.0]
image::https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/ChaCha_Cipher_Quarter_Round_Function.svg/382px-ChaCha_Cipher_Quarter_Round_Function.svg.png[ChaCha20 Round Function Diagram]

Note that the quarter round function can be split into two almost identical
"top" and "bottom" halves after the left rotation by `12`.
The only difference between top and bottom halves is the left rotation
amounts.

We use four instructions to compute an entire quarter round.
Each instruction takes two register operands `rs1` and `rs2`, which
each contain two 32-bit input elements to the Quarter Round function.
`rs1` contains inputs `A` and `D`. `rs2` contains inputs `B` and `C`.
Each instruction computes two intermediate or output elements of the
Quarter round function.

- `chacha.ad0` - Compute the top    half of the QR outputs for `A` and `D`.
- `chacha.bc0` - Compute the top    half of the QR outputs for `B` and `C`.
- `chacha.ad1` - Compute the bottom half of the QR outputs for `A` and `D`.
- `chacha.bc1` - Compute the bottom half of the QR outputs for `B` and `C`.

See the `ise.c` file to see how inputs are un-packed from the input
registers, and the exact calculations performed.

The `AD` and `BC` packing scheme (rather than `AB`,`CD`) means that
each instruction only needs a single 32-bit addition.
Computing `A` and `B` from `ABCD` would require two 32-bit adders
to appear in sequence, complicating the hardware implementation.

An entire quarter round function can hence be expressed as:

----
chacha20_qr:    // Inputs a0, a1 - Outputs a0, a1
    chacha20.ad0 a0, a0, a1
    chacha20.bc0 a1, a0, a1
    chacha20.ad1 a0, a0, a1
    chacha20.bc1 a1, a0, a1
----

This takes care of the quarter round, but ChaCha rounds alternate between
operating on columns of the state and diagonals.
Between rounds, we must then re-arrange the `8` registers which
represent the state in order to have the inputs the right form.
This problem only manifests on a packed representation of the state,
since such re-organisations of the state are trivial if only one elment
is stored per register.

We introduce a single new instruction to help with this:
`packhl`, which packs the high `32` bits of `rs1` and the low
`32` bits of `rs2` into the destination register.
This instruction is very similar to the `pack*` instructions in the
Bitmanip extension.
The instruction may be a good candidate for the Bitmanip extension on
its own.

A re-arrangement of the state into either columns or diagonals uses
`8` `packhl` instructions.

A round ChaCha using these instructions hence takes `4` instructions
per quarter round, plus `8` instructions for the state re-arrangement,
making `4*4+8=24` in total.
This adds up to `20*24=480` instructions in total for the main loop.

At the beginning of the loop, we need `8` load double instrucitons
to load the state into registers, and `8` Bitmanip `pack` and `packh`
instructions to pack the elements ready for the first round.

At the end of the loop, we must add each initial input element to the
corresponding output element.
This is slightly complicated by the packed nature of the loop outputs,
and takes `56` instructions in total, assuming that the initial state
cannot be kept un-modified in registers.

In total, this leads to approximately `56+480+16=552` instructions
for a complete ChaCha20 round function, or `1.85x` faster.

The ISE version of ChaCha can be run using `make run-ise`.

=== The ISE: Hardware cost,

An example Verilog implementation of the `chacha.*` instructions is found
in the `chacha_ise.v` file.

A very simple synthesis flow can be run using `make synthesise`, which
uses Yosys to produce post-synthesis cell counts and circuit depths.
These results are:

----
=== chacha_ise ===

   Number of cells:                667
     $_ANDNOT_                     101
     $_AND_                          3
     $_MUX_                        256
     $_NOR_                         16
     $_NOT_                        157
     $_ORNOT_                       10
     $_OR_                          29
     $_XNOR_                        14
     $_XOR_                         81

   Estimated number of transistors:       5448
   (Approx NAND2 Equivalent = 5448 / 4 = 1362)

Longest topological path in chacha_ise (length=25):
----

Note that the cost of the `packhl` is not included, it is assumed to
be *very small*.

=== The ISE: Possible improvements.

An obvious way to accelerate the ISE further would be to simply have
two Quarter Round Instructions:

- `chacha.ab` Compute the next values of `A` and `D` for a Quarter Round.
- `chacha.cb` Compute the next values of `C` and `B` for a Quarter Round.

These compute the entire quarter round:

----
chacha20_qr:
    chacha.ab   a2, a0, a1
    chacha.cd   a3, a0, a1
----

The same packing and re-packing operations would still be needed using
`pack`, `packh` and `packhl`.

The approximate instruction count would then be:
- `2` instructions per quarter round.
- `8` `chacha.*` instructions per round, plus `8` re-packing instructions.
- `20` rounds leads to `16*20=320` for the entire block loop.
- `320 + 16 preluede instructions + 56 exitlude instructions` = `392`
  instructions in total, or `2.61x` faster than the base implementation.

The downside of this approach is that it leads to a deeper circuit path
due to chaning three 32-bit adders in sequence in the worse case.
A deeper analysis of this could be done, but has been rejected out of
hand for now.
It may be that two 32-bit adders in sequence is acceptable on a 64-bit
base architecture, which by nessesity has 64-bit adders implemented
already.

== What about Macro-op fusion?

ChaCha is a very suitable candidate for macro-op fusion.
Assuming two-instruction sequences with upto two register operands
and a single register output may be fused, we arrive at the following
possible sequence:

- `xor A, B, C; rori, A, A, i` -  Occurs four times.

This reduces the per-quarter round instruction count from `12` to `8`.
A complete block operation would then be approximately
`48+16+(4*8)*20=704`
instructions.

Note that there is no 16-bit encoding for `rori`, and the compressed `xor`
can only address `8` registers.
To take full advantage, a core must then be able to fetch, decode and fuse
two 32-bit instructions per cycle.

More complex fusion sequences are possible iff one considers
more than two inputs or more than one output.

== Summary

We arrive at the following estimates:

.Summary of results for the RV64 ChaCha ISE.
|==================================================================
| Implementation         | Instructions Per Block   | Hardware Cost
| Base                   | `1024`                   |   `0`
| ISE as propsoed        |  `552`                   |   1.3K NAND2 gates
| Simple Macro-op Fusion |  `704`                   |   ?
|==================================================================

ChaCha was designed to be very efficient on a machines with no
dedicated hardware support.
My experience is that it resists further acceleration using ISEs very
well, due to subtle issues around data packing and circuit depth.
There may be other approaches to accelerating ChaCha (certainly,
vector instructions are possible) but this represents my best effort
for a scalar 64-bit data-path.
For a 32-bit datapath, macro-op fusion based acceleration is likely
the best way to go.

It may be that this proposal is a good starting point for a
standardisation candidate, but that will require people other than me
arguing for dedicated ChaCha acceleration support.
At the least, this proposal shows ChaCha has been considered.

== References

[bibliography]
- [[[rfc7539]]] "ChaCha20 and Poly1305 for IETF Protocols" https://tools.ietf.org/html/rfc7539
- [[[chachawiki]]] - "ChaCha Variant of Salsa20, Wikipedia" - https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant"
- [[[tls1.3]]] - "TLS 1.3 Mandatory-to-Implement Cipher Suites" - https://www.rfc-editor.org/rfc/rfc8446.html#section-9.1
- [[[wireguard]]] - "Wireguard Protocols and Cryptography" - https://www.wireguard.com/protocol/
