%!TEX root=../paper.tex
\subsection{ISE Design}

This Subsection presents the design of ISE focusing on accelerating the operation of the Chacha cipher's block function. 
The ISE assisted acceleration for the Chacha block function is fairly challenging especially for the scalar-register-based ISEs because 
a) The block function was designed to be very efficient on a machines without dedicated hardware support. 
b) The function computes on 32-bit state elements and two consecutive operations involves at least 3 state elements. 
The latter prevents the acceleration using the scalar-register-based ISEs on 32-bit RISC-V architecture without the capable of having more than 2 source operands.
Certainly, vector instructions are possible approaches to accelerating ChaCha. 
But in this paper, we focused on the scalar-register-based ISE approaches on 64-bit RISC-V architecture instead. 
This obviously provides a lower area overhead solution compared to vectorisation alternatives. 
The 64-bit architecture allows each instructions packing more Chacha state elements (e.g. 2-source-operands instructions can input 4 Chacha state elements). 
This enables the possibility of acceleration.

Our ISE designs obey the wider RISC-V design principles. 
This means they should support simple building-block operations, and their instruction encodings must be at most 2 source registers and 1 destination register. 
By following that the proposed ISEs can be straightforwardly integrated into different existing RISC-V implementations.
To ensure low area and latency overhead, the proposed ISEs follow further requirements: 
a) The operation of ISE can be implemented to execute in one clock cycle in its hardware module. 
b) The ISE must store operands and results in the RISC-V general-purpose scalar register file. 
c) The ISE must not introduce special-purpose architectural state, nor rely on special-purpose micro-architectural state (e.g., registers, caches or scratch-pad memory).
Overall, The proposed ISEs intentionally target at performing Chacha stream cipher on low(er)-end, resource-constrained (e.g., embedded) platforms. We view such a focus as reasonable, because existing work on adding cryptographic support to the standard vector extension [RV:19a,Section 21] already caters for high(er)-end alternatives. 

We arrive at four ISE variants using the requirements, the description of which is split into an intuitive description in the following Subsections 

\subsubsection{Variant 1 ($V_1$)}
$V_1$ is based on a performance-oriented approach which aims at executing the Chacha's quarter round with a minimal number of ISE as possible. 
Due to 1-destination-register constraint, the Chacha's quarter round can be executed at least two ISEs to compute 4 state elements of the quarter round.
Therefore, we propose two ISEs as following:

\begin{itemize}

\INST{chacha20.v1.ad    rd, rs1, rs2}{
  uint32\xspace $a,b,c,d, ia, ib, ic,id, na,nd$; \;
  $a \ASN \GPR[*][{{\VERB[ASM]{rs1}}}] \RSH 32; d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $ia \ASN a + b; id \ASN (ia \XOR  d) \LRT 16;$;
  $ic \ASN c +id; ib \ASN (ic \XOR  b) \LRT12;$ \;
  $na \ASN ia+ib; nd \ASN (id \XOR na) \LRT 8;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (na \LSH 32) \IOR nd;$ \;
}

\INST{chacha20.v1.bc    rd, rs1, rs2}{
  uint32\xspace $a,b,c,d, ib, ic,id, na,nd$; \;
  $a \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $id \ASN (d \LRT 24) \XOR a; ic \ASN c \XOR id; ib \ASN (b \XOR ic) \LRT 12;$ \;
  $nc \ASN ic+ d; nb \ASN (ib \XOR nc) \LRT 7;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}
\end{itemize}

Each instruction takes two 64-bit-register operands \VERB[ASM]{rs1} and \VERB[ASM]{rs2}, which each packs two 32-bit input elements of the Quarter Round function. \VERB[ASM]{rs1} contains inputs $iA$ and $iD$. \VERB[ASM]{rs2} contains inputs $iB$ and $iC$. \VERB{chacha20.v1.ad} (resp. \VERB{chacha20.v1.bc}) computes the outputs $oA$ and $oD$ (resp. $oB$ and $oC$) packed in its destination register \VERB[ASM]{rd}. 
These ISEs are used to implement the Chacha's quarter round as in Algorithm~\ref{alg::qr::v1}.

\begin{algorithm}
\KwData  {64-bit values $X=\{iA \CONS iD \}$ and $Y=\{iB \CONS iC \}$.
}
\KwResult{64-bit values $R0$, $R1$ such that $R0=\{oA \CONS oD \}$ and $R1=\{oB \CONS oC \}$).
}
\BlankLine
\KwFn{$\ALG{QUARTERROUND}( X, Y )$}{
  \VERB[ASM]{chacha20.v1.ad} R0, X, Y \;
  \VERB[ASM]{chacha20.v1.bc} R1, X, Y \;
  $\KwRet{\TUPLE{ R0, R1 }}$ \;
}
\caption{Chacha20's Quarter Round in Variant 1.}
\label{alg::qr::v1}
\end{algorithm}


\subsubsection{Variant 2 ($V_2$)}
As focusing on performance, the implementation of $V_1$ can lead to an un-optimal area overhead of, in the worst case, four 32-bit \VERB{Xors} and three 32-bit \VERB{Additions}. $V_2$ present a trade-off approach to reduce area overhead by introduce 3 ISEs. 
One ISE computes two intermediate values in the Chacha quarter round function from the input state elements.
The other two ISEs calculates the output elements from the intermediate values and the input elements.
These ISEs are able to share their computational hardware (e.g. adder). By doing so, the $V_2$ reduces the required number of 32-bit additions from three to two compared to $V_1$. The ISEs of $V_2$ are described as follows:

\begin{itemize}

\INST{chacha20.v2.bd    rd, rs1, rs2}{
  uint32\xspace $a,b,c,d, nb,nd$; \;
  $a \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $nd \ASN ((a + b) \XOR d) \LRT 16;$ 
  $nb \ASN ((c +nd) \XOR b) \LRT 12;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nd;$ \;
}

\INST{chacha20.v2.ad    rd, rs1, rs2}{
  uint32\xspace $a,b',d',d, nb,nd$; \;
  $a  \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; d  \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b' \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; d' \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $na \ASN b' + (d \XOR (d' \LRT 16));$; 
  $nd \ASN (na \XOR d') \LRT 8;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (na \LSH 32) \IOR nd;$ \;
}

\INST{chacha20.v2.bc    rd, rs1, rs2}{
  uint32\xspace $a,b,c,d, t, na,nd$; \;
  $a  \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b  \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $t  \ASN c + (d \LRT 24) \XOR a;$ \;
  $nc \ASN t + d; nb \ASN (nc \XOR ((b \XOR t) \LRT 12)) \LRT 7;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}
\end{itemize}

\VERB[ASM]{chacha20.v2.bd} computes the intermediate values packed in its destination resister \VERB[ASM]{rd} from 4 input elements $iA$, $iD$ (packed in \VERB[ASM]{rs1}), $iB$ and $iC$ (packed in \VERB[ASM]{rs2}).  \VERB{chacha20.v2.ad} (resp. \VERB{chacha20.v2.bc}) computes the outputs $oA$ and $oD$ (resp. $oB$ and $oC$) packed in its destination register \VERB[ASM]{rd} that is similar to the packing scheme in $V_1$. 
The Chacha's quarter round can be implemented with 3 instructions as in Algorithm~\ref{alg::qr::v2}.


\begin{algorithm}
\KwData  {64-bit values $X=\{iA \CONS iD \}$ and $Y=\{iB \CONS iC \}$.
}
\KwResult{64-bit values $R0$, $R1$ such that $R0=\{oA \CONS oD \}$ and $R1=\{oB \CONS oC \}$).
}
\BlankLine
\KwFn{$\ALG{QUARTERROUND}( X, Y )$}{
  \VERB[ASM]{chacha20.v2.bd} T, X, Y  \;
  \VERB[ASM]{chacha20.v2.ad} R0, X, T \;
  \VERB[ASM]{chacha20.v2.bc} R1, R0, Y  \;
  $\KwRet{\TUPLE{ R0, R1 }}$ \;
}
\caption{Chacha20's Quarter Round in Variant 2.}
\label{alg::qr::v2}
\end{algorithm}


\subsubsection{Variant 3 ($V_3$)}
$V_3$ introduces an area-efficiency-oriented approach which aims at favouring hardware re-usage between ISEs to reduce overall area overhead. 
The approach is based on observing that the quarter round function can be split into two almost identical "top" and "bottom" halves. 
Moreover, each half consists of almost identical operation sequence including addition, xor, and rotation.
The only difference between these operation sequences is the left rotation amounts. 
So, we invest four instructions to compute an entire quarter round as follows

\begin{itemize}

\INST{chacha20.v3.ad0    rd, rs1, rs2}{
  uint32\xspace $a,b,d na,nd$; \;
  $a \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32;$
  $d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $na \ASN a + b; nd \ASN (na \XOR d) \LRT 16;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (na \LSH 32) \IOR nd;$ \;
}

\INST{chacha20.v3.bc0    rd, rs1, rs2}{
  uint32\xspace $b,c,d, na,nd$; \;
  $b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$
  $d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $nc \ASN c + d; nb \ASN (nc \XOR b) \LRT 12;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}

\INST{chacha20.v3.ad1    rd, rs1, rs2}{
  uint32\xspace $a,b,d na,nd$; \;
  $a \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32;$
  $d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $na \ASN a + b; nd \ASN (na \XOR d) \LRT  8;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (na \LSH 32) \IOR nd;$ \;
}

\INST{chacha20.v3.bc1    rd, rs1, rs2}{
  uint32\xspace $b,c,d, na,nd$; \;
  $b \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; c \ASN \GPR[*][{\VERB[ASM]{rs2}}];$
  $d \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $nc \ASN c + d; nb \ASN (nc \XOR b) \LRT  7;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}
\end{itemize}

It can be seen that ISEs has a similar computational structure that allows to obtain an effective resource sharing for a low area cost implementation.
The first two ISEs (i.e. \VERB[ASM]{chacha20.v3.ad0} and \VERB[ASM]{chacha20.v3.bc0}) are used to compute the top half of the quarter round while the other two ISEs computer the bottom halve.
Again we use the similar packing scheme as in $V_1$ and $V_2$. So, the Chacha's quarter round can be implemented with 4 instructions as in Algorithm~\ref{alg::qr::v3}.

\begin{algorithm}
\KwData  {64-bit values $X=\{iA \CONS iD \}$ and $Y=\{iB \CONS iC \}$.
}
\KwResult{64-bit values $R0$, $R1$ such that $R0=\{oA \CONS oD \}$ and $R1=\{oB \CONS oC \}$).
}
\BlankLine
\KwFn{$\ALG{QUARTERROUND}( X, Y )$}{
  \VERB[ASM]{chacha20.v3.ad0} X', X, Y \;
  \VERB[ASM]{chacha20.v3.bc0} Y', X, Y \;
  \VERB[ASM]{chacha20.v3.ad1} R0, X', Y' \;
  \VERB[ASM]{chacha20.v3.bc1} R1, X', Y' \;
  $\KwRet{\TUPLE{ R0, R1 }}$ \;
}
\caption{Chacha20's Quarter Round in Variant 3.}
\label{alg::qr::v3}
\end{algorithm}


\subsubsection{Variant 4 ($V_4$)}
$V_4$ follows a parallel oriented approach which is different from the above ISEs approaches. By observing two consecutive Chacha quarter rounds have a similar computational structure, we invest a calculation scheme so that two quarter rounds, called half round, can be performed simultaneously. So, a Chacha round can be perform with two half rounds instead of four quarter rounds. To perform the half round effectively, 5 ISEs including one addition instruction and 4 xor-then-rotation instructions are proposed as below:     

\begin{itemize}

\INST{chacha20.v4.add   rd, rs1, rs2}{
  uint32\xspace $a1,a0, b1, b0, r1,r0$; \;
  $a1 \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; a0 \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b1 \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; b0 \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;
  $r1 \ASN a1 + b1; r0 \ASN a0 + b0;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (r1 \LSH 32) \IOR r0;$ \;
}

\INST{chacha20.v4.xorrol.16  rd, rs1, rs2}{
  uint32\xspace $a1,a0, b1, b0, r1, r0$; \;
  $a1 \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; a0 \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b1 \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; b0 \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;

  $r1 \ASN (a1 \XOR b1)\LRT 16; r0 \ASN (a0 \XOR b0)\LRT 16;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}

\INST{chacha20.v4.xorrol.12  rd, rs1, rs2}{
  uint32\xspace $a1,a0, b1, b0, r1, r0$; \;
  $a1 \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; a0 \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b1 \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; b0 \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;

  $r1 \ASN (a1 \XOR b1)\LRT 12; r0 \ASN (a0 \XOR b0)\LRT 12;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}

\INST{chacha20.v4.xorrol.8  rd, rs1, rs2}{
  uint32\xspace $a1,a0, b1, b0, r1, r0$; \;
  $a1 \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; a0 \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b1 \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; b0 \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;

  $r1 \ASN (a1 \XOR b1)\LRT 8; r0 \ASN (a0 \XOR b0)\LRT 8;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}

\INST{chacha20.v4.xorrol.7  rd, rs1, rs2}{
  uint32\xspace $a1,a0, b1, b0, r1, r0$; \;
  $a1 \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32; a0 \ASN \GPR[*][{\VERB[ASM]{rs1}}];$
  $b1 \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; b0 \ASN \GPR[*][{\VERB[ASM]{rs2}}];$ \;

  $r1 \ASN (a1 \XOR b1)\LRT 7; r0 \ASN (a0 \XOR b0)\LRT 7;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (nb \LSH 32) \IOR nc;$ \;
}
\end{itemize}

In these ISEs, each 64 bit source register packs 2 state elements which are at the same row and at two consecutive columns in a Chacha's state matrix and the corresponding two returned elements are packed in a destination register \VERB[ASM]{rd}. It can be viewed that the ISEs are vector-like instructions with the lenghth of two 32-bit elements. So, the Chacha's half round can be implemented (similarly to a quarter round) with 8 instructions as in Algorithm~\ref{alg::hr::v4}. $A$, $B$, $C$ and $D$ represent 4 rows of the Chacha's state matrix and the $c$ and $c+1$ subscript denote two consecutive columns.  

\begin{algorithm}
\KwData  {64-bit values $X=\{iA_c \CONS iA_{c+1}\}$, $Y=\{iB_c \CONS iB_{c+1}\}$, $Z=\{iC_c \CONS iC_{c+1}\}$ and $W=\{iD_c \CONS iD_{c+1}\}$.
}
\KwResult{64-bit values $R0=\{oA_c \CONS oA_{c+1}\}$, $R1=\{oB_c \CONS oB_{c+1}\}$, $R2=\{oC_c \CONS oC_{c+1}\}$ and $R3=\{oD_c \CONS oD_{c+1}\}$.
}
\BlankLine
\KwFn{$\ALG{HALFROUND}( X, Y, Z, W )$}{
  \VERB[ASM]{chacha20.v4.add}        X', X, Y  \;
  \VERB[ASM]{chacha20.v4.xorrol.16}  W', W, X' \;
  \VERB[ASM]{chacha20.v4.add}        Z', Z, W' \;
  \VERB[ASM]{chacha20.v4.xorrol.12}  Y', Y, Z' \;
  \VERB[ASM]{chacha20.v4.add}        R0, X', Y' \;
  \VERB[ASM]{chacha20.v4.xorrol.8}   R3, W', R0 \;
  \VERB[ASM]{chacha20.v4.add}        R2, Z', R3 \;
  \VERB[ASM]{chacha20.v4.xorrol.7}   R1, Y', R2 \;
  $\KwRet{\TUPLE{ R0, R1, R2, R3 }}$ \;
}
\caption{Chacha20's Half Round in Variant 4.}
\label{alg::hr::v4}
\end{algorithm}

\subsubsection{Packing assisted ISEs}
As the above ISEs work in packed mode, we consider packing instructions to help with this.
The packing instructions can be used at the beginning of the Chacha round to pack 16 state elements which represent the state matrix into 8 working registers. 
Moreover, ChaCha block function performs 20 rounds alternate between odd and even rounds. Between rounds, we must then re-pack the 8 registers  in order to the odd and even rounds can be executed with the same round function in software. The ISEs of $V_2$ are described as follows:

\begin{itemize}

\INST{pack    rd, rs1, rs2}{
  uint32\xspace $r2l, r1l$; \;
  $r2l \ASN \GPR[*][{\VERB[ASM]{rs2}}]; r1l \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (r2l \LSH 32) \IOR r1l;$ \;
}

\INST{packh    rd, rs1, rs2}{
  uint32\xspace $r2h, r1h$; \;
  $r2h \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; r1h \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (r2h \LSH 32) \IOR r1h;$ \;
}

\INST{packhl    rd, rs1, rs2}{
  uint32\xspace $r2h, r1l$; \;
  $r2h \ASN \GPR[*][{\VERB[ASM]{rs2}}] \RSH 32; r1l \ASN \GPR[*][{\VERB[ASM]{rs1}}];$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (r2h \LSH 32) \IOR r1l;$ \;
}

\INST{packlh    rd, rs1, rs2}{
  uint32\xspace $r2l, r1h$; \;
  $r2l \ASN \GPR[*][{\VERB[ASM]{rs2}}]; r1h \ASN \GPR[*][{\VERB[ASM]{rs1}}] \RSH 32;$ \;
  $\GPR[*][{\VERB[ASM]{rd}}] \ASN (r2l \LSH 32) \IOR r1h;$ \; 
}

\end{itemize}

These instructions are very similar to the pack* instructions in the Bitmanip extension [\ref{}] yet provide more flexible. 
%It is noted that the area cost of these instructions can be very small and account for a negligible part of the overall area overhead of the proposed ISEs. 
The Chacha round function using each ISE variants is implemented with different types of the packing instructions.

\subsection{Hardware Implementation}

\begin{table}
	\caption{Comparison of hardware overheads between ISE variants when synthesised for a
		generic CMOS cell library}
	\label{tab:res:sw:hardcost1}
	\begin{tabular}{lcc}
		\toprule            
		Implementations        & Size (NAND2 cells)    & Depth  \\
		
		\midrule
		+ ISE $V_1$ &     2353     & 56   \\
		+ ISE $V_2$ &     2494     & 41   \\
		+ ISE $V_3$ &     1362     & 25   \\
		+ ISE $V_4$ &     1617     & 19   \\
		
		\bottomrule
	\end{tabular}
\end{table}

\begin{table}
	\caption{Comparison of hardware overheads between sub-modules}
	\label{tab:res:sw:hardcost2}
	\begin{tabular}{lcc}
		\toprule            
		Algorithm        &     Size (NAND2 cells)     & Depth \\
		
		\midrule
		RV64 Rocket Core &    98150     &   91  \\
		~~~~~|-- ALU     &     3719     &   28  \\
		~~~~~|-- Muldiv  &    17171     &   40  \\
		+ ISE $V_4$      &     1617     &   19  \\ 
		
		\bottomrule
	\end{tabular}
\end{table}


